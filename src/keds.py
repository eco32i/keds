import os
import numpy as np
import pandas as pd


def norm_factor28(theta):
    '''
    2/8% normalization as described in SHAPE-seq paper.
    '''
    theta_ = theta.order(ascending=False)
    theta_ = theta_[theta_ > 0]
    top2 = int(round(0.02 * theta_.count()))
    next8 = int(round(0.08 * theta_[top2:].count()))
    return theta / theta_[top2:next8].mean()

def norm_default(theta):
    '''
    Default normalization as described in Aviran et al. 2011
    '''
    return theta / -1. * np.log(1-theta).sum()

def parse_sample(barcode, dirname='../data'):
    '''
    Parses pileup files generated by `samtools` mpileup command  for `plus` and
    `minus` channels. Returns dataframe with counts for each position.

    `barcode` can be anything (in my case actual barcode used to tag RNA)
    '''
    file_plus = os.path.join(dirname, '{0}_plus.pileup'.format(barcode))
    file_minus = os.path.join(dirname, '{0}_minus.pileup'.format(barcode))
    with open(file_plus, 'rb') as _plus, open(file_minus, 'rb') as _minus:
        reader_plus = csv.DictReader(_plus, delimiter='\t', fieldnames=['seqname', 'pos', 'base', 'coverage', 'details', 'qual'])    
        reader_minus = csv.DictReader(_minus, delimiter='\t', fieldnames=['seqname', 'pos', 'base', 'coverage', 'details', 'qual'])    
        data = []
        for rec1,rec2 in zip(reader_plus, reader_minus):
            pos = int(rec1['pos'])
            last = (rec1, rec2)
            if pos == 1:
                data.append({'pos': 0, 'base': '*', 
                             'plus': rec1['details'].count('^'),
                             'minus': rec2['details'].count('^')})
            else:
                data.append({'pos': pos-1, 'base': last[0]['base'],
                             'plus': rec1['details'].count('^'),
                             'minus': rec2['details'].count('^')})
       # This is an incorrect, off-by-one implementation
       # data = [{'pos': int(rec1['pos']),
       #          'base': rec1['base'],
       #          'plus': rec1['details'].count('^'),
       #          'minus': rec2['details'].count('^'),} for rec1,rec2 in izip(reader_plus, reader_minus)]
    return pd.DataFrame.from_records(data)

def compute_theta(data, norm=norm_default):
    '''
    Computes theta as per Aviran et al. 2011
    '''
    df = data.copy()
    df['plus_S'] = df['plus'].cumsum()
    df['minus_S'] = df['minus'].cumsum()
    df = df.reindex(index=df.index[::-1])
    theta = np.log(1-df['minus']/df['minus_S']) - np.log(1-df['plus']/df['plus_S'])
    theta[theta < 0] = 0
    return norm(theta)[::-1]
